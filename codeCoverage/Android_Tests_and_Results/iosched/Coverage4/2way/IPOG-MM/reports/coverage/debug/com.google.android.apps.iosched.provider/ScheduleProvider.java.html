<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScheduleProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">com.google.android.apps.iosched.provider</a> &gt; <span class="el_source">ScheduleProvider.java</span></div><h1>ScheduleProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.apps.iosched.provider;

import com.google.android.apps.iosched.provider.ScheduleContract.Blocks;
import com.google.android.apps.iosched.provider.ScheduleContract.Rooms;
import com.google.android.apps.iosched.provider.ScheduleContract.SearchSuggest;
import com.google.android.apps.iosched.provider.ScheduleContract.Sessions;
import com.google.android.apps.iosched.provider.ScheduleContract.Speakers;
import com.google.android.apps.iosched.provider.ScheduleContract.Tracks;
import com.google.android.apps.iosched.provider.ScheduleContract.Vendors;
import com.google.android.apps.iosched.provider.ScheduleDatabase.SessionsSearchColumns;
import com.google.android.apps.iosched.provider.ScheduleDatabase.SessionsSpeakers;
import com.google.android.apps.iosched.provider.ScheduleDatabase.SessionsTracks;
import com.google.android.apps.iosched.provider.ScheduleDatabase.Tables;
import com.google.android.apps.iosched.provider.ScheduleDatabase.VendorsSearchColumns;
import com.google.android.apps.iosched.service.SyncService;
import com.google.android.apps.iosched.util.SelectionBuilder;

import android.app.Activity;
import android.app.SearchManager;
import android.content.ContentProvider;
import android.content.ContentProviderOperation;
import android.content.ContentProviderResult;
import android.content.ContentValues;
import android.content.Context;
import android.content.OperationApplicationException;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.provider.BaseColumns;
import android.util.Log;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Provider that stores {@link ScheduleContract} data. Data is usually inserted
 * by {@link SyncService}, and queried by various {@link Activity} instances.
 */
<span class="fc" id="L59">public class ScheduleProvider extends ContentProvider {</span>
    private static final String TAG = &quot;ScheduleProvider&quot;;
<span class="fc" id="L61">    private static final boolean LOGV = Log.isLoggable(TAG, Log.VERBOSE);</span>

    private ScheduleDatabase mOpenHelper;

<span class="fc" id="L65">    private static final UriMatcher sUriMatcher = buildUriMatcher();</span>

    private static final int BLOCKS = 100;
    private static final int BLOCKS_BETWEEN = 101;
    private static final int BLOCKS_ID = 102;
    private static final int BLOCKS_ID_SESSIONS = 103;

    private static final int TRACKS = 200;
    private static final int TRACKS_ID = 201;
    private static final int TRACKS_ID_SESSIONS = 202;
    private static final int TRACKS_ID_VENDORS = 203;

    private static final int ROOMS = 300;
    private static final int ROOMS_ID = 301;
    private static final int ROOMS_ID_SESSIONS = 302;

    private static final int SESSIONS = 400;
    private static final int SESSIONS_STARRED = 401;
    private static final int SESSIONS_SEARCH = 402;
    private static final int SESSIONS_AT = 403;
    private static final int SESSIONS_ID = 404;
    private static final int SESSIONS_ID_SPEAKERS = 405;
    private static final int SESSIONS_ID_TRACKS = 406;

    private static final int SPEAKERS = 500;
    private static final int SPEAKERS_ID = 501;
    private static final int SPEAKERS_ID_SESSIONS = 502;

    private static final int VENDORS = 600;
    private static final int VENDORS_STARRED = 601;
    private static final int VENDORS_SEARCH = 603;
    private static final int VENDORS_ID = 604;

    private static final int SEARCH_SUGGEST = 800;

    private static final String MIME_XML = &quot;text/xml&quot;;

    /**
     * Build and return a {@link UriMatcher} that catches all {@link Uri}
     * variations supported by this {@link ContentProvider}.
     */
    private static UriMatcher buildUriMatcher() {
<span class="fc" id="L107">        final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);</span>
<span class="fc" id="L108">        final String authority = ScheduleContract.CONTENT_AUTHORITY;</span>

<span class="fc" id="L110">        matcher.addURI(authority, &quot;blocks&quot;, BLOCKS);</span>
<span class="fc" id="L111">        matcher.addURI(authority, &quot;blocks/between/*/*&quot;, BLOCKS_BETWEEN);</span>
<span class="fc" id="L112">        matcher.addURI(authority, &quot;blocks/*&quot;, BLOCKS_ID);</span>
<span class="fc" id="L113">        matcher.addURI(authority, &quot;blocks/*/sessions&quot;, BLOCKS_ID_SESSIONS);</span>

<span class="fc" id="L115">        matcher.addURI(authority, &quot;tracks&quot;, TRACKS);</span>
<span class="fc" id="L116">        matcher.addURI(authority, &quot;tracks/*&quot;, TRACKS_ID);</span>
<span class="fc" id="L117">        matcher.addURI(authority, &quot;tracks/*/sessions&quot;, TRACKS_ID_SESSIONS);</span>
<span class="fc" id="L118">        matcher.addURI(authority, &quot;tracks/*/vendors&quot;, TRACKS_ID_VENDORS);</span>

<span class="fc" id="L120">        matcher.addURI(authority, &quot;rooms&quot;, ROOMS);</span>
<span class="fc" id="L121">        matcher.addURI(authority, &quot;rooms/*&quot;, ROOMS_ID);</span>
<span class="fc" id="L122">        matcher.addURI(authority, &quot;rooms/*/sessions&quot;, ROOMS_ID_SESSIONS);</span>

<span class="fc" id="L124">        matcher.addURI(authority, &quot;sessions&quot;, SESSIONS);</span>
<span class="fc" id="L125">        matcher.addURI(authority, &quot;sessions/starred&quot;, SESSIONS_STARRED);</span>
<span class="fc" id="L126">        matcher.addURI(authority, &quot;sessions/search/*&quot;, SESSIONS_SEARCH);</span>
<span class="fc" id="L127">        matcher.addURI(authority, &quot;sessions/at/*&quot;, SESSIONS_AT);</span>
<span class="fc" id="L128">        matcher.addURI(authority, &quot;sessions/*&quot;, SESSIONS_ID);</span>
<span class="fc" id="L129">        matcher.addURI(authority, &quot;sessions/*/speakers&quot;, SESSIONS_ID_SPEAKERS);</span>
<span class="fc" id="L130">        matcher.addURI(authority, &quot;sessions/*/tracks&quot;, SESSIONS_ID_TRACKS);</span>

<span class="fc" id="L132">        matcher.addURI(authority, &quot;speakers&quot;, SPEAKERS);</span>
<span class="fc" id="L133">        matcher.addURI(authority, &quot;speakers/*&quot;, SPEAKERS_ID);</span>
<span class="fc" id="L134">        matcher.addURI(authority, &quot;speakers/*/sessions&quot;, SPEAKERS_ID_SESSIONS);</span>

<span class="fc" id="L136">        matcher.addURI(authority, &quot;vendors&quot;, VENDORS);</span>
<span class="fc" id="L137">        matcher.addURI(authority, &quot;vendors/starred&quot;, VENDORS_STARRED);</span>
<span class="fc" id="L138">        matcher.addURI(authority, &quot;vendors/search/*&quot;, VENDORS_SEARCH);</span>
<span class="fc" id="L139">        matcher.addURI(authority, &quot;vendors/*&quot;, VENDORS_ID);</span>

<span class="fc" id="L141">        matcher.addURI(authority, &quot;search_suggest_query&quot;, SEARCH_SUGGEST);</span>

<span class="fc" id="L143">        return matcher;</span>
    }

    @Override
    public boolean onCreate() {
<span class="fc" id="L148">        final Context context = getContext();</span>
<span class="fc" id="L149">        mOpenHelper = new ScheduleDatabase(context);</span>
<span class="fc" id="L150">        return true;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String getType(Uri uri) {
<span class="fc" id="L156">        final int match = sUriMatcher.match(uri);</span>
<span class="pc bpc" id="L157" title="21 of 26 branches missed.">        switch (match) {</span>
            case BLOCKS:
<span class="nc" id="L159">                return Blocks.CONTENT_TYPE;</span>
            case BLOCKS_BETWEEN:
<span class="nc" id="L161">                return Blocks.CONTENT_TYPE;</span>
            case BLOCKS_ID:
<span class="nc" id="L163">                return Blocks.CONTENT_ITEM_TYPE;</span>
            case BLOCKS_ID_SESSIONS:
<span class="fc" id="L165">                return Sessions.CONTENT_TYPE;</span>
            case TRACKS:
<span class="fc" id="L167">                return Tracks.CONTENT_TYPE;</span>
            case TRACKS_ID:
<span class="nc" id="L169">                return Tracks.CONTENT_ITEM_TYPE;</span>
            case TRACKS_ID_SESSIONS:
<span class="fc" id="L171">                return Sessions.CONTENT_TYPE;</span>
            case TRACKS_ID_VENDORS:
<span class="nc" id="L173">                return Vendors.CONTENT_TYPE;</span>
            case ROOMS:
<span class="nc" id="L175">                return Rooms.CONTENT_TYPE;</span>
            case ROOMS_ID:
<span class="nc" id="L177">                return Rooms.CONTENT_ITEM_TYPE;</span>
            case ROOMS_ID_SESSIONS:
<span class="nc" id="L179">                return Sessions.CONTENT_TYPE;</span>
            case SESSIONS:
<span class="fc" id="L181">                return Sessions.CONTENT_TYPE;</span>
            case SESSIONS_STARRED:
<span class="nc" id="L183">                return Sessions.CONTENT_TYPE;</span>
            case SESSIONS_SEARCH:
<span class="nc" id="L185">                return Sessions.CONTENT_TYPE;</span>
            case SESSIONS_AT:
<span class="nc" id="L187">                return Sessions.CONTENT_TYPE;</span>
            case SESSIONS_ID:
<span class="fc" id="L189">                return Sessions.CONTENT_ITEM_TYPE;</span>
            case SESSIONS_ID_SPEAKERS:
<span class="nc" id="L191">                return Speakers.CONTENT_TYPE;</span>
            case SESSIONS_ID_TRACKS:
<span class="nc" id="L193">                return Tracks.CONTENT_TYPE;</span>
            case SPEAKERS:
<span class="nc" id="L195">                return Speakers.CONTENT_TYPE;</span>
            case SPEAKERS_ID:
<span class="nc" id="L197">                return Speakers.CONTENT_ITEM_TYPE;</span>
            case SPEAKERS_ID_SESSIONS:
<span class="nc" id="L199">                return Sessions.CONTENT_TYPE;</span>
            case VENDORS:
<span class="nc" id="L201">                return Vendors.CONTENT_TYPE;</span>
            case VENDORS_STARRED:
<span class="nc" id="L203">                return Vendors.CONTENT_TYPE;</span>
            case VENDORS_SEARCH:
<span class="nc" id="L205">                return Vendors.CONTENT_TYPE;</span>
            case VENDORS_ID:
<span class="nc" id="L207">                return Vendors.CONTENT_ITEM_TYPE;</span>
            default:
<span class="nc" id="L209">                throw new UnsupportedOperationException(&quot;Unknown uri: &quot; + uri);</span>
        }
    }

    /** {@inheritDoc} */
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
            String sortOrder) {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (LOGV) Log.v(TAG, &quot;query(uri=&quot; + uri + &quot;, proj=&quot; + Arrays.toString(projection) + &quot;)&quot;);</span>
<span class="fc" id="L218">        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();</span>

<span class="fc" id="L220">        final int match = sUriMatcher.match(uri);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        switch (match) {</span>
            default: {
                // Most cases are handled with simple SelectionBuilder
<span class="fc" id="L224">                final SelectionBuilder builder = buildExpandedSelection(uri, match);</span>
<span class="fc" id="L225">                return builder.where(selection, selectionArgs).query(db, projection, sortOrder);</span>
            }
            case SEARCH_SUGGEST: {
<span class="nc" id="L228">                final SelectionBuilder builder = new SelectionBuilder();</span>

                // Adjust incoming query to become SQL text match
<span class="nc" id="L231">                selectionArgs[0] = selectionArgs[0] + &quot;%&quot;;</span>
<span class="nc" id="L232">                builder.table(Tables.SEARCH_SUGGEST);</span>
<span class="nc" id="L233">                builder.where(selection, selectionArgs);</span>
<span class="nc" id="L234">                builder.map(SearchManager.SUGGEST_COLUMN_QUERY,</span>
                        SearchManager.SUGGEST_COLUMN_TEXT_1);

<span class="nc" id="L237">                projection = new String[] { BaseColumns._ID, SearchManager.SUGGEST_COLUMN_TEXT_1,</span>
                        SearchManager.SUGGEST_COLUMN_QUERY };

<span class="nc" id="L240">                final String limit = uri.getQueryParameter(SearchManager.SUGGEST_PARAMETER_LIMIT);</span>
<span class="nc" id="L241">                return builder.query(db, projection, null, null, SearchSuggest.DEFAULT_SORT, limit);</span>
            }
        }
    }

    /** {@inheritDoc} */
    @Override
    public Uri insert(Uri uri, ContentValues values) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (LOGV) Log.v(TAG, &quot;insert(uri=&quot; + uri + &quot;, values=&quot; + values.toString() + &quot;)&quot;);</span>
<span class="fc" id="L250">        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();</span>
<span class="fc" id="L251">        final int match = sUriMatcher.match(uri);</span>
<span class="pc bpc" id="L252" title="4 of 10 branches missed.">        switch (match) {</span>
            case BLOCKS: {
<span class="fc" id="L254">                db.insertOrThrow(Tables.BLOCKS, null, values);</span>
<span class="fc" id="L255">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L256">                return Blocks.buildBlockUri(values.getAsString(Blocks.BLOCK_ID));</span>
            }
            case TRACKS: {
<span class="fc" id="L259">                db.insertOrThrow(Tables.TRACKS, null, values);</span>
<span class="fc" id="L260">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L261">                return Tracks.buildTrackUri(values.getAsString(Tracks.TRACK_ID));</span>
            }
            case ROOMS: {
<span class="fc" id="L264">                db.insertOrThrow(Tables.ROOMS, null, values);</span>
<span class="fc" id="L265">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L266">                return Rooms.buildRoomUri(values.getAsString(Rooms.ROOM_ID));</span>
            }
            case SESSIONS: {
<span class="fc" id="L269">                db.insertOrThrow(Tables.SESSIONS, null, values);</span>
<span class="fc" id="L270">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L271">                return Sessions.buildSessionUri(values.getAsString(Sessions.SESSION_ID));</span>
            }
            case SESSIONS_ID_SPEAKERS: {
<span class="nc" id="L274">                db.insertOrThrow(Tables.SESSIONS_SPEAKERS, null, values);</span>
<span class="nc" id="L275">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="nc" id="L276">                return Speakers.buildSpeakerUri(values.getAsString(SessionsSpeakers.SPEAKER_ID));</span>
            }
            case SESSIONS_ID_TRACKS: {
<span class="fc" id="L279">                db.insertOrThrow(Tables.SESSIONS_TRACKS, null, values);</span>
<span class="fc" id="L280">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L281">                return Tracks.buildTrackUri(values.getAsString(SessionsTracks.TRACK_ID));</span>
            }
            case SPEAKERS: {
<span class="nc" id="L284">                db.insertOrThrow(Tables.SPEAKERS, null, values);</span>
<span class="nc" id="L285">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="nc" id="L286">                return Speakers.buildSpeakerUri(values.getAsString(Speakers.SPEAKER_ID));</span>
            }
            case VENDORS: {
<span class="nc" id="L289">                db.insertOrThrow(Tables.VENDORS, null, values);</span>
<span class="nc" id="L290">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="nc" id="L291">                return Vendors.buildVendorUri(values.getAsString(Vendors.VENDOR_ID));</span>
            }
            case SEARCH_SUGGEST: {
<span class="fc" id="L294">                db.insertOrThrow(Tables.SEARCH_SUGGEST, null, values);</span>
<span class="fc" id="L295">                getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L296">                return SearchSuggest.CONTENT_URI;</span>
            }
            default: {
<span class="nc" id="L299">                throw new UnsupportedOperationException(&quot;Unknown uri: &quot; + uri);</span>
            }
        }
    }

    /** {@inheritDoc} */
    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (LOGV) Log.v(TAG, &quot;update(uri=&quot; + uri + &quot;, values=&quot; + values.toString() + &quot;)&quot;);</span>
<span class="nc" id="L308">        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();</span>
<span class="nc" id="L309">        final SelectionBuilder builder = buildSimpleSelection(uri);</span>
<span class="nc" id="L310">        int retVal = builder.where(selection, selectionArgs).update(db, values);</span>
<span class="nc" id="L311">        getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="nc" id="L312">        return retVal;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (LOGV) Log.v(TAG, &quot;delete(uri=&quot; + uri + &quot;)&quot;);</span>
<span class="fc" id="L319">        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();</span>
<span class="fc" id="L320">        final SelectionBuilder builder = buildSimpleSelection(uri);</span>
<span class="fc" id="L321">        int retVal = builder.where(selection, selectionArgs).delete(db);</span>
<span class="fc" id="L322">        getContext().getContentResolver().notifyChange(uri, null);</span>
<span class="fc" id="L323">        return retVal;</span>
    }

    /**
     * Apply the given set of {@link ContentProviderOperation}, executing inside
     * a {@link SQLiteDatabase} transaction. All changes will be rolled back if
     * any single one fails.
     */
    @Override
    public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
            throws OperationApplicationException {
<span class="fc" id="L334">        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();</span>
<span class="fc" id="L335">        db.beginTransaction();</span>
        try {
<span class="fc" id="L337">            final int numOperations = operations.size();</span>
<span class="fc" id="L338">            final ContentProviderResult[] results = new ContentProviderResult[numOperations];</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for (int i = 0; i &lt; numOperations; i++) {</span>
<span class="fc" id="L340">                results[i] = operations.get(i).apply(this, results, i);</span>
            }
<span class="fc" id="L342">            db.setTransactionSuccessful();</span>
<span class="fc" id="L343">            return results;</span>
        } finally {
<span class="pc" id="L345">            db.endTransaction();</span>
<span class="nc" id="L346">        }</span>
    }

    /**
     * Build a simple {@link SelectionBuilder} to match the requested
     * {@link Uri}. This is usually enough to support {@link #insert},
     * {@link #update}, and {@link #delete} operations.
     */
    private SelectionBuilder buildSimpleSelection(Uri uri) {
<span class="fc" id="L355">        final SelectionBuilder builder = new SelectionBuilder();</span>
<span class="fc" id="L356">        final int match = sUriMatcher.match(uri);</span>
<span class="pc bpc" id="L357" title="13 of 16 branches missed.">        switch (match) {</span>
            case BLOCKS: {
<span class="fc" id="L359">                return builder.table(Tables.BLOCKS);</span>
            }
            case BLOCKS_ID: {
<span class="nc" id="L362">                final String blockId = Blocks.getBlockId(uri);</span>
<span class="nc" id="L363">                return builder.table(Tables.BLOCKS)</span>
<span class="nc" id="L364">                        .where(Blocks.BLOCK_ID + &quot;=?&quot;, blockId);</span>
            }
            case TRACKS: {
<span class="fc" id="L367">                return builder.table(Tables.TRACKS);</span>
            }
            case TRACKS_ID: {
<span class="nc" id="L370">                final String trackId = Tracks.getTrackId(uri);</span>
<span class="nc" id="L371">                return builder.table(Tables.TRACKS)</span>
<span class="nc" id="L372">                        .where(Tracks.TRACK_ID + &quot;=?&quot;, trackId);</span>
            }
            case ROOMS: {
<span class="nc" id="L375">                return builder.table(Tables.ROOMS);</span>
            }
            case ROOMS_ID: {
<span class="nc" id="L378">                final String roomId = Rooms.getRoomId(uri);</span>
<span class="nc" id="L379">                return builder.table(Tables.ROOMS)</span>
<span class="nc" id="L380">                        .where(Rooms.ROOM_ID + &quot;=?&quot;, roomId);</span>
            }
            case SESSIONS: {
<span class="nc" id="L383">                return builder.table(Tables.SESSIONS);</span>
            }
            case SESSIONS_ID: {
<span class="nc" id="L386">                final String sessionId = Sessions.getSessionId(uri);</span>
<span class="nc" id="L387">                return builder.table(Tables.SESSIONS)</span>
<span class="nc" id="L388">                        .where(Sessions.SESSION_ID + &quot;=?&quot;, sessionId);</span>
            }
            case SESSIONS_ID_SPEAKERS: {
<span class="nc" id="L391">                final String sessionId = Sessions.getSessionId(uri);</span>
<span class="nc" id="L392">                return builder.table(Tables.SESSIONS_SPEAKERS)</span>
<span class="nc" id="L393">                        .where(Sessions.SESSION_ID + &quot;=?&quot;, sessionId);</span>
            }
            case SESSIONS_ID_TRACKS: {
<span class="nc" id="L396">                final String sessionId = Sessions.getSessionId(uri);</span>
<span class="nc" id="L397">                return builder.table(Tables.SESSIONS_TRACKS)</span>
<span class="nc" id="L398">                        .where(Sessions.SESSION_ID + &quot;=?&quot;, sessionId);</span>
            }
            case SPEAKERS: {
<span class="nc" id="L401">                return builder.table(Tables.SPEAKERS);</span>
            }
            case SPEAKERS_ID: {
<span class="nc" id="L404">                final String speakerId = Speakers.getSpeakerId(uri);</span>
<span class="nc" id="L405">                return builder.table(Tables.SPEAKERS)</span>
<span class="nc" id="L406">                        .where(Speakers.SPEAKER_ID + &quot;=?&quot;, speakerId);</span>
            }
            case VENDORS: {
<span class="nc" id="L409">                return builder.table(Tables.VENDORS);</span>
            }
            case VENDORS_ID: {
<span class="nc" id="L412">                final String vendorId = Vendors.getVendorId(uri);</span>
<span class="nc" id="L413">                return builder.table(Tables.VENDORS)</span>
<span class="nc" id="L414">                        .where(Vendors.VENDOR_ID + &quot;=?&quot;, vendorId);</span>
            }
            case SEARCH_SUGGEST: {
<span class="fc" id="L417">                return builder.table(Tables.SEARCH_SUGGEST);</span>
            }
            default: {
<span class="nc" id="L420">                throw new UnsupportedOperationException(&quot;Unknown uri: &quot; + uri);</span>
            }
        }
    }

    /**
     * Build an advanced {@link SelectionBuilder} to match the requested
     * {@link Uri}. This is usually only used by {@link #query}, since it
     * performs table joins useful for {@link Cursor} data.
     */
    private SelectionBuilder buildExpandedSelection(Uri uri, int match) {
<span class="fc" id="L431">        final SelectionBuilder builder = new SelectionBuilder();</span>
<span class="pc bpc" id="L432" title="16 of 26 branches missed.">        switch (match) {</span>
            case BLOCKS: {
<span class="nc" id="L434">                return builder.table(Tables.BLOCKS);</span>
            }
            case BLOCKS_BETWEEN: {
<span class="fc" id="L437">                final List&lt;String&gt; segments = uri.getPathSegments();</span>
<span class="fc" id="L438">                final String startTime = segments.get(2);</span>
<span class="fc" id="L439">                final String endTime = segments.get(3);</span>
<span class="fc" id="L440">                return builder.table(Tables.BLOCKS)</span>
<span class="fc" id="L441">                        .map(Blocks.SESSIONS_COUNT, Subquery.BLOCK_SESSIONS_COUNT)</span>
<span class="fc" id="L442">                        .map(Blocks.CONTAINS_STARRED, Subquery.BLOCK_CONTAINS_STARRED)</span>
<span class="fc" id="L443">                        .where(Blocks.BLOCK_START + &quot;&gt;=?&quot;, startTime)</span>
<span class="fc" id="L444">                        .where(Blocks.BLOCK_START + &quot;&lt;=?&quot;, endTime);</span>
            }
            case BLOCKS_ID: {
<span class="nc" id="L447">                final String blockId = Blocks.getBlockId(uri);</span>
<span class="nc" id="L448">                return builder.table(Tables.BLOCKS)</span>
<span class="nc" id="L449">                        .map(Blocks.SESSIONS_COUNT, Subquery.BLOCK_SESSIONS_COUNT)</span>
<span class="nc" id="L450">                        .map(Blocks.CONTAINS_STARRED, Subquery.BLOCK_CONTAINS_STARRED)</span>
<span class="nc" id="L451">                        .where(Blocks.BLOCK_ID + &quot;=?&quot;, blockId);</span>
            }
            case BLOCKS_ID_SESSIONS: {
<span class="fc" id="L454">                final String blockId = Blocks.getBlockId(uri);</span>
<span class="fc" id="L455">                return builder.table(Tables.SESSIONS_JOIN_BLOCKS_ROOMS)</span>
<span class="fc" id="L456">                        .map(Blocks.SESSIONS_COUNT, Subquery.BLOCK_SESSIONS_COUNT)</span>
<span class="fc" id="L457">                        .map(Blocks.CONTAINS_STARRED, Subquery.BLOCK_CONTAINS_STARRED)</span>
<span class="fc" id="L458">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="fc" id="L459">                        .mapToTable(Sessions.SESSION_ID, Tables.SESSIONS)</span>
<span class="fc" id="L460">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="fc" id="L461">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="fc" id="L462">                        .where(Qualified.SESSIONS_BLOCK_ID + &quot;=?&quot;, blockId);</span>
            }
            case TRACKS: {
<span class="fc" id="L465">                return builder.table(Tables.TRACKS)</span>
<span class="fc" id="L466">                        .map(Tracks.SESSIONS_COUNT, Subquery.TRACK_SESSIONS_COUNT)</span>
<span class="fc" id="L467">                        .map(Tracks.VENDORS_COUNT, Subquery.TRACK_VENDORS_COUNT);</span>
            }
            case TRACKS_ID: {
<span class="fc" id="L470">                final String trackId = Tracks.getTrackId(uri);</span>
<span class="fc" id="L471">                return builder.table(Tables.TRACKS)</span>
<span class="fc" id="L472">                        .where(Tracks.TRACK_ID + &quot;=?&quot;, trackId);</span>
            }
            case TRACKS_ID_SESSIONS: {
<span class="fc" id="L475">                final String trackId = Tracks.getTrackId(uri);</span>
<span class="fc" id="L476">                return builder.table(Tables.SESSIONS_TRACKS_JOIN_SESSIONS_BLOCKS_ROOMS)</span>
<span class="fc" id="L477">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="fc" id="L478">                        .mapToTable(Sessions.SESSION_ID, Tables.SESSIONS)</span>
<span class="fc" id="L479">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="fc" id="L480">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="fc" id="L481">                        .where(Qualified.SESSIONS_TRACKS_TRACK_ID + &quot;=?&quot;, trackId);</span>
            }
            case TRACKS_ID_VENDORS: {
<span class="nc" id="L484">                final String trackId = Tracks.getTrackId(uri);</span>
<span class="nc" id="L485">                return builder.table(Tables.VENDORS_JOIN_TRACKS)</span>
<span class="nc" id="L486">                        .mapToTable(Vendors._ID, Tables.VENDORS)</span>
<span class="nc" id="L487">                        .mapToTable(Vendors.TRACK_ID, Tables.VENDORS)</span>
<span class="nc" id="L488">                        .where(Qualified.VENDORS_TRACK_ID + &quot;=?&quot;, trackId);</span>
            }
            case ROOMS: {
<span class="nc" id="L491">                return builder.table(Tables.ROOMS);</span>
            }
            case ROOMS_ID: {
<span class="nc" id="L494">                final String roomId = Rooms.getRoomId(uri);</span>
<span class="nc" id="L495">                return builder.table(Tables.ROOMS)</span>
<span class="nc" id="L496">                        .where(Rooms.ROOM_ID + &quot;=?&quot;, roomId);</span>
            }
            case ROOMS_ID_SESSIONS: {
<span class="nc" id="L499">                final String roomId = Rooms.getRoomId(uri);</span>
<span class="nc" id="L500">                return builder.table(Tables.SESSIONS_JOIN_BLOCKS_ROOMS)</span>
<span class="nc" id="L501">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="nc" id="L502">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="nc" id="L503">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="nc" id="L504">                        .where(Qualified.SESSIONS_ROOM_ID + &quot;=?&quot;, roomId);</span>
            }
            case SESSIONS: {
<span class="fc" id="L507">                return builder.table(Tables.SESSIONS_JOIN_BLOCKS_ROOMS)</span>
<span class="fc" id="L508">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="fc" id="L509">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="fc" id="L510">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS);</span>
            }
            case SESSIONS_STARRED: {
<span class="fc" id="L513">                return builder.table(Tables.SESSIONS_JOIN_BLOCKS_ROOMS)</span>
<span class="fc" id="L514">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="fc" id="L515">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="fc" id="L516">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="fc" id="L517">                        .where(Sessions.SESSION_STARRED + &quot;=1&quot;);</span>
            }
            case SESSIONS_SEARCH: {
<span class="nc" id="L520">                final String query = Sessions.getSearchQuery(uri);</span>
<span class="nc" id="L521">                return builder.table(Tables.SESSIONS_SEARCH_JOIN_SESSIONS_BLOCKS_ROOMS)</span>
<span class="nc" id="L522">                        .map(Sessions.SEARCH_SNIPPET, Subquery.SESSIONS_SNIPPET)</span>
<span class="nc" id="L523">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="nc" id="L524">                        .mapToTable(Sessions.SESSION_ID, Tables.SESSIONS)</span>
<span class="nc" id="L525">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="nc" id="L526">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="nc" id="L527">                        .where(SessionsSearchColumns.BODY + &quot; MATCH ?&quot;, query);</span>
            }
            case SESSIONS_AT: {
<span class="nc" id="L530">                final List&lt;String&gt; segments = uri.getPathSegments();</span>
<span class="nc" id="L531">                final String time = segments.get(2);</span>
<span class="nc" id="L532">                return builder.table(Tables.SESSIONS_JOIN_BLOCKS_ROOMS)</span>
<span class="nc" id="L533">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="nc" id="L534">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="nc" id="L535">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="nc" id="L536">                        .where(Sessions.BLOCK_START + &quot;&lt;=?&quot;, time)</span>
<span class="nc" id="L537">                        .where(Sessions.BLOCK_END + &quot;&gt;=?&quot;, time);</span>
            }
            case SESSIONS_ID: {
<span class="fc" id="L540">                final String sessionId = Sessions.getSessionId(uri);</span>
<span class="fc" id="L541">                return builder.table(Tables.SESSIONS_JOIN_BLOCKS_ROOMS)</span>
<span class="fc" id="L542">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="fc" id="L543">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="fc" id="L544">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="fc" id="L545">                        .where(Qualified.SESSIONS_SESSION_ID + &quot;=?&quot;, sessionId);</span>
            }
            case SESSIONS_ID_SPEAKERS: {
<span class="fc" id="L548">                final String sessionId = Sessions.getSessionId(uri);</span>
<span class="fc" id="L549">                return builder.table(Tables.SESSIONS_SPEAKERS_JOIN_SPEAKERS)</span>
<span class="fc" id="L550">                        .mapToTable(Speakers._ID, Tables.SPEAKERS)</span>
<span class="fc" id="L551">                        .mapToTable(Speakers.SPEAKER_ID, Tables.SPEAKERS)</span>
<span class="fc" id="L552">                        .where(Qualified.SESSIONS_SPEAKERS_SESSION_ID + &quot;=?&quot;, sessionId);</span>
            }
            case SESSIONS_ID_TRACKS: {
<span class="nc" id="L555">                final String sessionId = Sessions.getSessionId(uri);</span>
<span class="nc" id="L556">                return builder.table(Tables.SESSIONS_TRACKS_JOIN_TRACKS)</span>
<span class="nc" id="L557">                        .mapToTable(Tracks._ID, Tables.TRACKS)</span>
<span class="nc" id="L558">                        .mapToTable(Tracks.TRACK_ID, Tables.TRACKS)</span>
<span class="nc" id="L559">                        .where(Qualified.SESSIONS_TRACKS_SESSION_ID + &quot;=?&quot;, sessionId);</span>
            }
            case SPEAKERS: {
<span class="nc" id="L562">                return builder.table(Tables.SPEAKERS);</span>
            }
            case SPEAKERS_ID: {
<span class="nc" id="L565">                final String speakerId = Speakers.getSpeakerId(uri);</span>
<span class="nc" id="L566">                return builder.table(Tables.SPEAKERS)</span>
<span class="nc" id="L567">                        .where(Speakers.SPEAKER_ID + &quot;=?&quot;, speakerId);</span>
            }
            case SPEAKERS_ID_SESSIONS: {
<span class="nc" id="L570">                final String speakerId = Speakers.getSpeakerId(uri);</span>
<span class="nc" id="L571">                return builder.table(Tables.SESSIONS_SPEAKERS_JOIN_SESSIONS_BLOCKS_ROOMS)</span>
<span class="nc" id="L572">                        .mapToTable(Sessions._ID, Tables.SESSIONS)</span>
<span class="nc" id="L573">                        .mapToTable(Sessions.SESSION_ID, Tables.SESSIONS)</span>
<span class="nc" id="L574">                        .mapToTable(Sessions.BLOCK_ID, Tables.SESSIONS)</span>
<span class="nc" id="L575">                        .mapToTable(Sessions.ROOM_ID, Tables.SESSIONS)</span>
<span class="nc" id="L576">                        .where(Qualified.SESSIONS_SPEAKERS_SPEAKER_ID + &quot;=?&quot;, speakerId);</span>
            }
            case VENDORS: {
<span class="nc" id="L579">                return builder.table(Tables.VENDORS_JOIN_TRACKS)</span>
<span class="nc" id="L580">                        .mapToTable(Vendors._ID, Tables.VENDORS)</span>
<span class="nc" id="L581">                        .mapToTable(Vendors.TRACK_ID, Tables.VENDORS);</span>
            }
            case VENDORS_STARRED: {
<span class="fc" id="L584">                return builder.table(Tables.VENDORS_JOIN_TRACKS)</span>
<span class="fc" id="L585">                        .mapToTable(Vendors._ID, Tables.VENDORS)</span>
<span class="fc" id="L586">                        .mapToTable(Vendors.TRACK_ID, Tables.VENDORS)</span>
<span class="fc" id="L587">                        .where(Vendors.VENDOR_STARRED + &quot;=1&quot;);</span>
            }
            case VENDORS_SEARCH: {
<span class="nc" id="L590">                final String query = Vendors.getSearchQuery(uri);</span>
<span class="nc" id="L591">                return builder.table(Tables.VENDORS_SEARCH_JOIN_VENDORS_TRACKS)</span>
<span class="nc" id="L592">                        .map(Vendors.SEARCH_SNIPPET, Subquery.VENDORS_SNIPPET)</span>
<span class="nc" id="L593">                        .mapToTable(Vendors._ID, Tables.VENDORS)</span>
<span class="nc" id="L594">                        .mapToTable(Vendors.VENDOR_ID, Tables.VENDORS)</span>
<span class="nc" id="L595">                        .mapToTable(Vendors.TRACK_ID, Tables.VENDORS)</span>
<span class="nc" id="L596">                        .where(VendorsSearchColumns.BODY + &quot; MATCH ?&quot;, query);</span>
            }
            case VENDORS_ID: {
<span class="nc" id="L599">                final String vendorId = Vendors.getVendorId(uri);</span>
<span class="nc" id="L600">                return builder.table(Tables.VENDORS_JOIN_TRACKS)</span>
<span class="nc" id="L601">                        .mapToTable(Vendors._ID, Tables.VENDORS)</span>
<span class="nc" id="L602">                        .mapToTable(Vendors.TRACK_ID, Tables.VENDORS)</span>
<span class="nc" id="L603">                        .where(Vendors.VENDOR_ID + &quot;=?&quot;, vendorId);</span>
            }
            default: {
<span class="nc" id="L606">                throw new UnsupportedOperationException(&quot;Unknown uri: &quot; + uri);</span>
            }
        }
    }

    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
<span class="nc" id="L613">        final int match = sUriMatcher.match(uri);</span>
<span class="nc" id="L614">        switch (match) {</span>
            default: {
<span class="nc" id="L616">                throw new UnsupportedOperationException(&quot;Unknown uri: &quot; + uri);</span>
            }
        }
    }

    private interface Subquery {
        String BLOCK_SESSIONS_COUNT = &quot;(SELECT COUNT(&quot; + Qualified.SESSIONS_SESSION_ID + &quot;) FROM &quot;
                + Tables.SESSIONS + &quot; WHERE &quot; + Qualified.SESSIONS_BLOCK_ID + &quot;=&quot;
                + Qualified.BLOCKS_BLOCK_ID + &quot;)&quot;;

        String BLOCK_CONTAINS_STARRED = &quot;(SELECT MAX(&quot; + Qualified.SESSIONS_STARRED + &quot;) FROM &quot;
                + Tables.SESSIONS + &quot; WHERE &quot; + Qualified.SESSIONS_BLOCK_ID + &quot;=&quot;
                + Qualified.BLOCKS_BLOCK_ID + &quot;)&quot;;

        String TRACK_SESSIONS_COUNT = &quot;(SELECT COUNT(&quot; + Qualified.SESSIONS_TRACKS_SESSION_ID
                + &quot;) FROM &quot; + Tables.SESSIONS_TRACKS + &quot; WHERE &quot;
                + Qualified.SESSIONS_TRACKS_TRACK_ID + &quot;=&quot; + Qualified.TRACKS_TRACK_ID + &quot;)&quot;;

        String TRACK_VENDORS_COUNT = &quot;(SELECT COUNT(&quot; + Qualified.VENDORS_VENDOR_ID + &quot;) FROM &quot;
                + Tables.VENDORS + &quot; WHERE &quot; + Qualified.VENDORS_TRACK_ID + &quot;=&quot;
                + Qualified.TRACKS_TRACK_ID + &quot;)&quot;;

        String SESSIONS_SNIPPET = &quot;snippet(&quot; + Tables.SESSIONS_SEARCH + &quot;,'{','}','\u2026')&quot;;
        String VENDORS_SNIPPET = &quot;snippet(&quot; + Tables.VENDORS_SEARCH + &quot;,'{','}','\u2026')&quot;;
    }

    /**
     * {@link ScheduleContract} fields that are fully qualified with a specific
     * parent {@link Tables}. Used when needed to work around SQL ambiguity.
     */
    private interface Qualified {
        String SESSIONS_SESSION_ID = Tables.SESSIONS + &quot;.&quot; + Sessions.SESSION_ID;
        String SESSIONS_BLOCK_ID = Tables.SESSIONS + &quot;.&quot; + Sessions.BLOCK_ID;
        String SESSIONS_ROOM_ID = Tables.SESSIONS + &quot;.&quot; + Sessions.ROOM_ID;

        String SESSIONS_TRACKS_SESSION_ID = Tables.SESSIONS_TRACKS + &quot;.&quot;
                + SessionsTracks.SESSION_ID;
        String SESSIONS_TRACKS_TRACK_ID = Tables.SESSIONS_TRACKS + &quot;.&quot;
                + SessionsTracks.TRACK_ID;

        String SESSIONS_SPEAKERS_SESSION_ID = Tables.SESSIONS_SPEAKERS + &quot;.&quot;
                + SessionsSpeakers.SESSION_ID;
        String SESSIONS_SPEAKERS_SPEAKER_ID = Tables.SESSIONS_SPEAKERS + &quot;.&quot;
                + SessionsSpeakers.SPEAKER_ID;

        String VENDORS_VENDOR_ID = Tables.VENDORS + &quot;.&quot; + Vendors.VENDOR_ID;
        String VENDORS_TRACK_ID = Tables.VENDORS + &quot;.&quot; + Vendors.TRACK_ID;

        @SuppressWarnings(&quot;hiding&quot;)
        String SESSIONS_STARRED = Tables.SESSIONS + &quot;.&quot; + Sessions.SESSION_STARRED;

        String TRACKS_TRACK_ID = Tables.TRACKS + &quot;.&quot; + Tracks.TRACK_ID;
        String BLOCKS_BLOCK_ID = Tables.BLOCKS + &quot;.&quot; + Blocks.BLOCK_ID;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span>Generated by the Android Gradle plugin 3.5.2</div></body></html>